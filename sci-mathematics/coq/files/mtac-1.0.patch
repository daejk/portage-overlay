diff -rupN coq-8.4pl1//Makefile.build coq-8.4pl1M//Makefile.build
--- coq-8.4pl1//Makefile.build	2012-10-29 15:46:37.000000000 +0100
+++ coq-8.4pl1M//Makefile.build	2013-03-15 21:14:05.000000000 +0100
@@ -209,7 +209,7 @@ coqbinaries:: ${COQBINARIES} ${CSDPCERT}
 
 coq: coqlib tools coqbinaries
 
-coqlib:: theories plugins
+coqlib:: theories plugins mtac
 
 coqlight: theories-light tools coqbinaries
 
@@ -499,6 +499,14 @@ theories/Numbers/Natural/BigN/NMake_gen.
 	$(OCAML) $< $(TOTARGET)
 
 ###########################################################################
+# Mtac
+###########################################################################
+
+mtac: $(COQC) theories plugins
+	$(COQC) -coqlib . $(MTACV)
+
+
+###########################################################################
 # tools
 ###########################################################################
 
@@ -657,6 +665,9 @@ endif
 	$(INSTALLBIN) $(CSDPCERT) $(FULLCOQLIB)/plugins/micromega
 	rm -f $(FULLCOQLIB)/revision
 	-$(INSTALLLIB) revision $(FULLCOQLIB)
+#mtac
+	$(MKDIR) $(FULLCOQLIB)/user-contrib/Mtac
+	$(INSTALLLIB) user-contrib/Mtac/*.vo $(FULLCOQLIB)/user-contrib/Mtac
 
 install-library-light:
 	$(MKDIR) $(FULLCOQLIB)
diff -rupN coq-8.4pl1//Makefile.common coq-8.4pl1M//Makefile.common
--- coq-8.4pl1//Makefile.common	2012-10-29 15:46:40.000000000 +0100
+++ coq-8.4pl1M//Makefile.common	2013-03-15 06:50:29.000000000 +0100
@@ -270,6 +270,7 @@ COQDOCCMO:=$(CONFIG) $(addprefix tools/c
 ## we now retrieve the names of .vo file to compile in */vo.itarget files
 
 cat_vo_itarget = $(addprefix $(1)/,$(shell cat $(1)/vo.itarget))
+cat_v_itarget = $(addprefix $(1)/,$(shell cat $(1)/v.itarget))
 
 ## Theories
 
@@ -297,6 +298,8 @@ SETOIDSVO:=$(call cat_vo_itarget, theori
 UNICODEVO:=$(call cat_vo_itarget, theories/Unicode)
 CLASSESVO:=$(call cat_vo_itarget, theories/Classes)
 PROGRAMVO:=$(call cat_vo_itarget, theories/Program)
+MTACV:=$(call cat_v_itarget, user-contrib/Mtac)
+
 
 THEORIESVO:=\
   $(INITVO) $(LOGICVO) $(ARITHVO) $(BOOLVO) $(PARITHVO) $(NARITHVO) $(ZARITHVO) \
diff -rupN coq-8.4pl1//dev/printers.mllib coq-8.4pl1M//dev/printers.mllib
--- coq-8.4pl1//dev/printers.mllib	2012-01-21 00:52:15.000000000 +0100
+++ coq-8.4pl1M//dev/printers.mllib	2013-01-18 11:05:35.000000000 +0100
@@ -93,6 +93,7 @@ Indrec
 Coercion
 Unification
 Cases
+Run
 Pretyping
 Declaremods
 
diff -rupN coq-8.4pl1//interp/constrextern.ml coq-8.4pl1M//interp/constrextern.ml
--- coq-8.4pl1//interp/constrextern.ml	2012-12-18 08:01:12.000000000 +0100
+++ coq-8.4pl1M//interp/constrextern.ml	2013-01-18 11:05:35.000000000 +0100
@@ -752,6 +752,8 @@ let rec extern inctx scopes vars r =
   | GCast (loc,c, CastCoerce) ->
       CCast (loc,sub_extern true scopes vars c, CastCoerce)
 
+  | GRun (loc, c) -> (*BETA*) CRun (loc, extern inctx scopes vars c)
+
 and extern_typ (_,scopes) =
   extern true (Some Notation.type_scope,scopes)
 
diff -rupN coq-8.4pl1//interp/constrintern.ml coq-8.4pl1M//interp/constrintern.ml
--- coq-8.4pl1//interp/constrintern.ml	2012-12-17 18:53:23.000000000 +0100
+++ coq-8.4pl1M//interp/constrintern.ml	2013-01-18 11:05:35.000000000 +0100
@@ -1351,6 +1351,7 @@ let internalize sigma globalenv env allo
 	GCast (loc,intern env c1, CastConv (k, intern_type env c2))
     | CCast (loc, c1, CastCoerce) ->
 	GCast (loc,intern env c1, CastCoerce)
+    | CRun (loc, c) -> GRun (loc, intern env c) (*BETA*)
 
   and intern_type env = intern (set_type_scope env)
 
diff -rupN coq-8.4pl1//interp/implicit_quantifiers.ml coq-8.4pl1M//interp/implicit_quantifiers.ml
--- coq-8.4pl1//interp/implicit_quantifiers.ml	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//interp/implicit_quantifiers.ml	2013-01-18 11:05:35.000000000 +0100
@@ -183,6 +183,7 @@ let generalizable_vars_of_glob_constr ?(
     | GCast (loc,c,k) -> let v = vars bound vs c in
 	(match k with CastConv (_,t) -> vars bound v t | _ -> v)
     | (GSort _ | GHole _ | GRef _ | GEvar _ | GPatVar _) -> vs
+    | GRun (_, e) -> (*BETA*) vars bound vs e
 
   and vars_pattern bound vs (loc,idl,p,c) =
     let bound' = List.fold_right Idset.add idl bound  in
diff -rupN coq-8.4pl1//interp/topconstr.ml coq-8.4pl1M//interp/topconstr.ml
--- coq-8.4pl1//interp/topconstr.ml	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//interp/topconstr.ml	2013-03-04 09:16:35.000000000 +0100
@@ -48,6 +48,8 @@ type aconstr =
   | AHole of Evd.hole_kind
   | APatVar of patvar
   | ACast of aconstr * aconstr cast_type
+  (* BETA *)
+  | ARun of aconstr
 
 type scope_name = string
 
@@ -155,6 +157,8 @@ let glob_constr_of_aconstr_with_binders
   | AHole x  -> GHole (loc,x)
   | APatVar n -> GPatVar (loc,(false,n))
   | ARef x -> GRef (loc,x)
+  (* BETA *)
+  | ARun x -> GRun (loc, f e x)
 
 let rec glob_constr_of_aconstr loc x =
   let rec aux () x =
@@ -200,6 +204,7 @@ let compare_glob_constr f add t1 t2 = ma
   | GSort (_,s1), GSort (_,s2) -> s1 = s2
   | GLetIn (_,na1,b1,c1), GLetIn (_,na2,b2,c2) when na1 = na2 ->
       on_true_do (f b1 b2 & f c1 c2) add na1
+  | GRun (_, e1), GRun (_, e2) -> (*BETA*) f e1 e2
   | (GCases _ | GRec _
     | GPatVar _ | GEvar _ | GLetTuple _ | GIf _ | GCast _),_
   | _,(GCases _ | GRec _
@@ -323,7 +328,8 @@ let aconstr_and_vars_of_glob_constr a =
   | GPatVar (_,(_,n)) -> APatVar n
   | GEvar _ ->
       error "Existential variables not allowed in notations."
-
+  (*BETA*)
+  | GRun (_,c) -> ARun (aux c)
   in
   let t = aux a in
   (* Side effect *)
@@ -886,6 +892,7 @@ type constr_expr =
   | CGeneralization of loc * binding_kind * abstraction_kind option * constr_expr
   | CPrim of loc * prim_token
   | CDelimiters of loc * string * constr_expr
+  | CRun of loc * constr_expr (*BETA*)
 
 and fix_expr =
     identifier located * (identifier located option * recursion_order_expr) * local_binder list * constr_expr * constr_expr
@@ -957,6 +964,7 @@ let constr_loc = function
   | CGeneralization (loc,_,_,_) -> loc
   | CPrim (loc,_) -> loc
   | CDelimiters (loc,_,_) -> loc
+  | CRun (loc, _) -> loc (*BETA*)
 
 let cases_pattern_expr_loc = function
   | CPatAlias (loc,_,_) -> loc
@@ -1076,6 +1084,7 @@ let fold_constr_expr_with_binders g f n
 	  (fold_local_binders g f n acc t lb) c lb) l acc
   | CCoFix (loc,_,_) ->
       Pp.warning "Capture check in multiple binders not done"; acc
+  | CRun (_, c) -> f n acc c (*BETA*)
 
 let free_vars_of_constr_expr c =
   let rec aux bdvars l = function
@@ -1240,6 +1249,7 @@ let map_constr_expr_with_binders g f e =
         let e'' = List.fold_left (fun e ((_,id),_,_,_) -> g id e) e' dl in
         let d' = f e'' d in
         (id,bl',t',d')) dl)
+  | CRun (loc, c) -> CRun (loc, f e c) (*BETA*)
 
 (* Used in constrintern *)
 let rec replace_vars_constr_expr l = function
diff -rupN coq-8.4pl1//interp/topconstr.mli coq-8.4pl1M//interp/topconstr.mli
--- coq-8.4pl1//interp/topconstr.mli	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//interp/topconstr.mli	2013-03-01 18:27:30.000000000 +0100
@@ -45,6 +45,8 @@ type aconstr =
   | AHole of Evd.hole_kind
   | APatVar of patvar
   | ACast of aconstr * aconstr cast_type
+  (* BETA *)
+  | ARun of aconstr
 
 type scope_name = string
 
@@ -165,6 +167,7 @@ type constr_expr =
   | CGeneralization of loc * binding_kind * abstraction_kind option * constr_expr
   | CPrim of loc * prim_token
   | CDelimiters of loc * string * constr_expr
+  | CRun of loc * constr_expr (*BETA*)
 
 and fix_expr =
     identifier located * (identifier located option * recursion_order_expr) * local_binder list * constr_expr * constr_expr
diff -rupN coq-8.4pl1//parsing/g_constr.ml4 coq-8.4pl1M//parsing/g_constr.ml4
--- coq-8.4pl1//parsing/g_constr.ml4	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//parsing/g_constr.ml4	2013-01-18 11:05:35.000000000 +0100
@@ -203,8 +203,12 @@ GEXTEND Gram
 	  CGeneralization (loc, Implicit, None, c)
       | "`("; c = operconstr LEVEL "200"; ")" ->
 	  CGeneralization (loc, Explicit, None, c)
+      | run(*BETA*); c = operconstr LEVEL "200" -> CRun (loc, c)
       ] ]
   ;
+  run: (*BETA*)
+    [ [ "run" -> () ] ]
+  ;
   forall:
     [ [ "forall" -> () ] ]
   ;
diff -rupN coq-8.4pl1//parsing/ppconstr.ml coq-8.4pl1M//parsing/ppconstr.ml
--- coq-8.4pl1//parsing/ppconstr.ml	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//parsing/ppconstr.ml	2013-01-18 11:05:35.000000000 +0100
@@ -550,6 +550,9 @@ let pr pr sep inherited a =
   | CGeneralization (_,bk,ak,c) -> pr_generalization bk ak (pr mt ltop c), latom
   | CPrim (_,p) -> pr_prim_token p, prec_of_prim_token p
   | CDelimiters (_,sc,a) -> pr_delimiters sc (pr mt (ldelim,E) a), ldelim
+  | CRun (_, c) -> (*BETA*)
+      hv 0 (hov 2 (str "run " ++ pr spc ltop c)),
+      latom
   in
   let loc = constr_loc a in
   pr_with_comments loc
diff -rupN coq-8.4pl1//plugins/subtac/subtac_pretyping_F.ml coq-8.4pl1M//plugins/subtac/subtac_pretyping_F.ml
--- coq-8.4pl1//plugins/subtac/subtac_pretyping_F.ml	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//plugins/subtac/subtac_pretyping_F.ml	2013-03-26 16:59:07.000000000 +0100
@@ -555,6 +555,10 @@ module SubtacPretyping_F (Coercion : Coe
 	in
 	  inh_conv_coerce_to_tycon loc env evdref cj tycon
 
+(* BETA *)
+     | GRun (loc, c) ->
+        Run.pretype_run pretype inh_conv_coerce_to_tycon tycon env evdref lvar loc c	 
+
   (* [pretype_type valcon env evdref lvar c] coerces [c] into a type *)
   and pretype_type valcon env evdref lvar = function
     | GHole loc ->
diff -rupN coq-8.4pl1//pretyping/detyping.ml coq-8.4pl1M//pretyping/detyping.ml
--- coq-8.4pl1//pretyping/detyping.ml	2012-12-17 18:53:17.000000000 +0100
+++ coq-8.4pl1M//pretyping/detyping.ml	2013-01-18 11:05:35.000000000 +0100
@@ -677,6 +677,10 @@ let rec subst_glob_constr subst raw =
 	     let r1' = subst_glob_constr subst r1 in
 	       if r1' == r1 then raw else GCast (loc,r1',k))
 
+  | GRun (loc, r) -> (*BETA*)
+    let r' = subst_glob_constr subst r in
+    if r' == r then raw else GRun (loc, r')
+
 (* Utilities to transform kernel cases to simple pattern-matching problem *)
 
 let simple_cases_matrix_of_branches ind brs =
diff -rupN coq-8.4pl1//pretyping/evarconv.ml coq-8.4pl1M//pretyping/evarconv.ml
--- coq-8.4pl1//pretyping/evarconv.ml	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//pretyping/evarconv.ml	2013-01-18 11:05:35.000000000 +0100
@@ -165,6 +165,8 @@ let ise_array2 evd f v1 v2 =
   if lv1 = Array.length v2 then allrec evd (pred lv1)
   else (evd,false)
 
+let use_eta = ref true
+
 let rec evar_conv_x ts env evd pbty term1 term2 =
   let term1 = whd_head_evar evd term1 in
   let term2 = whd_head_evar evd term2 in
@@ -425,7 +427,7 @@ and evar_eqappr_x ?(rhs_is_already_stuck
 	ise_try evd [f3; f4]
 
     (* Eta-expansion *)
-    | Rigid c1, _ when isLambda c1 ->
+    | Rigid c1, _ when !use_eta && isLambda c1 ->
 	assert (l1 = []);
 	let (na,c1,c'1) = destLambda c1 in
         let c = nf_evar evd c1 in
@@ -434,7 +436,7 @@ and evar_eqappr_x ?(rhs_is_already_stuck
 	let appr2 = (lift 1 term2, List.map (lift 1) l2 @ [mkRel 1]) in
 	evar_eqappr_x ts env' evd CONV appr1 appr2
 
-    | _, Rigid c2 when isLambda c2 ->
+    | _, Rigid c2 when !use_eta && isLambda c2 ->
 	assert (l2 = []);
 	let (na,c2,c'2) = destLambda c2 in
         let c = nf_evar evd c2 in
@@ -847,22 +849,26 @@ let consider_remaining_unif_problems ?(t
 
 (* Main entry points *)
 
-let the_conv_x ?(ts=full_transparent_state) env t1 t2 evd =
+let the_conv_x ?(eta=true) ?(ts=full_transparent_state) env t1 t2 evd =
+  use_eta := eta;
   match evar_conv_x ts env evd CONV  t1 t2 with
       (evd',true) -> evd'
     | _ -> raise Reduction.NotConvertible
 
 let the_conv_x_leq ?(ts=full_transparent_state) env t1 t2 evd =
+  use_eta := true;
   match evar_conv_x ts env evd CUMUL t1 t2 with
       (evd', true) -> evd'
     | _ -> raise Reduction.NotConvertible
 
 let e_conv ?(ts=full_transparent_state) env evdref t1 t2 =
+  use_eta := true;
   match evar_conv_x ts env !evdref CONV t1 t2 with
       (evd',true) -> evdref := evd'; true
     | _ -> false
 
 let e_cumul ?(ts=full_transparent_state) env evdref t1 t2 =
+  use_eta := true;
   match evar_conv_x ts env !evdref CUMUL t1 t2 with
       (evd',true) -> evdref := evd'; true
     | _ -> false
diff -rupN coq-8.4pl1//pretyping/evarconv.mli coq-8.4pl1M//pretyping/evarconv.mli
--- coq-8.4pl1//pretyping/evarconv.mli	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//pretyping/evarconv.mli	2013-01-18 11:05:35.000000000 +0100
@@ -15,7 +15,7 @@ open Reductionops
 open Evd
 
 (** returns exception Reduction.NotConvertible if not unifiable *)
-val the_conv_x     : ?ts:transparent_state -> env -> constr -> constr -> evar_map -> evar_map
+val the_conv_x     : ?eta:bool -> ?ts:transparent_state -> env -> constr -> constr -> evar_map -> evar_map
 val the_conv_x_leq : ?ts:transparent_state -> env -> constr -> constr -> evar_map -> evar_map
 
 (** The same function resolving evars by side-effect and
diff -rupN coq-8.4pl1//pretyping/glob_term.ml coq-8.4pl1M//pretyping/glob_term.ml
--- coq-8.4pl1//pretyping/glob_term.ml	2012-12-18 08:01:12.000000000 +0100
+++ coq-8.4pl1M//pretyping/glob_term.ml	2013-01-18 11:05:35.000000000 +0100
@@ -67,6 +67,7 @@ type glob_constr =
   | GSort of loc * glob_sort
   | GHole of (loc * hole_kind)
   | GCast of loc * glob_constr * glob_constr cast_type
+  | GRun of (loc * glob_constr) (*BETA*)
 
 and glob_decl = name * binding_kind * glob_constr option * glob_constr
 
@@ -144,6 +145,8 @@ let map_glob_constr_left_to_right f = fu
       let comp2 = match k with CastConv (k,t) -> CastConv (k, f t) | x -> x in
       GCast (loc,comp1,comp2)
   | (GVar _ | GSort _ | GHole _ | GRef _ | GEvar _ | GPatVar _) as x -> x
+  | GRun (loc,c) -> (*BETA*)
+      GRun (loc, f c)
 
 let map_glob_constr = map_glob_constr_left_to_right
 
@@ -205,6 +208,8 @@ let fold_glob_constr f acc =
 	Array.fold_left fold (Array.fold_left fold acc tyl) bv
     | GCast (_,c,k) -> fold (match k with CastConv (_, t) -> fold acc t | CastCoerce -> acc) c
     | (GSort _ | GHole _ | GRef _ | GEvar _ | GPatVar _) -> acc
+    | GRun (_,c) -> (*BETA*)
+      fold acc c
 
   and fold_pattern acc (_,idl,p,c) = fold acc c
 
@@ -244,6 +249,8 @@ let occur_glob_constr id =
           idl bl tyl bv)
     | GCast (loc,c,k) -> (occur c) or (match k with CastConv (_, t) -> occur t | CastCoerce -> false)
     | (GSort _ | GHole _ | GRef _ | GEvar _ | GPatVar _) -> false
+    | GRun (loc,c) -> (*BETA*)
+        occur c
 
   and occur_pattern (loc,idl,p,c) = not (List.mem id idl) & (occur c)
 
@@ -302,6 +309,8 @@ let free_glob_vars  =
     | GCast (loc,c,k) -> let v = vars bounded vs c in
 	(match k with CastConv (_,t) -> vars bounded v t | _ -> v)
     | (GSort _ | GHole _ | GRef _ | GEvar _ | GPatVar _) -> vs
+    | GRun (_, c) -> (*BETA*) 
+        vars bounded vs c
 
   and vars_pattern bounded vs (loc,idl,p,c) =
     let bounded' = List.fold_right Idset.add idl bounded  in
@@ -334,6 +343,7 @@ let loc_of_glob_constr = function
   | GSort (loc,_) -> loc
   | GHole (loc,_) -> loc
   | GCast (loc,_,_) -> loc
+  | GRun (loc, _) -> loc (*BETA*) 
 
 (**********************************************************************)
 (* Conversion from glob_constr to cases pattern, if possible            *)
diff -rupN coq-8.4pl1//pretyping/glob_term.mli coq-8.4pl1M//pretyping/glob_term.mli
--- coq-8.4pl1//pretyping/glob_term.mli	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//pretyping/glob_term.mli	2013-01-18 11:05:35.000000000 +0100
@@ -71,6 +71,7 @@ type glob_constr =
   | GSort of loc * glob_sort
   | GHole of (loc * Evd.hole_kind)
   | GCast of loc * glob_constr * glob_constr cast_type
+  | GRun of (loc * glob_constr) (*BETA*)
 
 and glob_decl = name * binding_kind * glob_constr option * glob_constr
 
diff -rupN coq-8.4pl1//pretyping/pretype_errors.ml coq-8.4pl1M//pretyping/pretype_errors.ml
--- coq-8.4pl1//pretyping/pretype_errors.ml	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//pretyping/pretype_errors.ml	2013-03-25 09:15:04.000000000 +0100
@@ -39,6 +39,8 @@ type pretype_error =
   | UnexpectedType of constr * constr
   | NotProduct of constr
   | TypingError of type_error
+  (* BETA *)
+  | UncaughtUserException of constr
 
 exception PretypeError of env * Evd.evar_map * pretype_error
 
@@ -184,3 +186,7 @@ let error_not_product_loc loc env sigma
 
 let error_var_not_found_loc loc s =
   raise_pretype_error (loc, empty_env, Evd.empty, VarNotFound s)
+
+(* BETA *)
+let error_user_exception loc env sigma c =
+  raise_pretype_error (loc, env, sigma, UncaughtUserException c)
diff -rupN coq-8.4pl1//pretyping/pretype_errors.mli coq-8.4pl1M//pretyping/pretype_errors.mli
--- coq-8.4pl1//pretyping/pretype_errors.mli	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//pretyping/pretype_errors.mli	2013-03-25 09:15:04.000000000 +0100
@@ -38,6 +38,8 @@ type pretype_error =
   | UnexpectedType of constr * constr
   | NotProduct of constr
   | TypingError of Type_errors.type_error
+  (* BETA *)
+  | UncaughtUserException of constr
 
 exception PretypeError of env * Evd.evar_map * pretype_error
 
@@ -129,3 +131,7 @@ val error_not_product_loc :
 (** {6 Error in conversion from AST to glob_constr } *)
 
 val error_var_not_found_loc : loc -> identifier -> 'b
+
+(* BETA *)
+val error_user_exception :
+  loc -> env -> Evd.evar_map -> constr -> 'b
diff -rupN coq-8.4pl1//pretyping/pretyping.ml coq-8.4pl1M//pretyping/pretyping.ml
--- coq-8.4pl1//pretyping/pretyping.ml	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//pretyping/pretyping.ml	2013-03-26 16:59:07.000000000 +0100
@@ -692,6 +692,9 @@ module Pretyping_F (Coercion : Coercion.
 		  { uj_val = v; uj_type = tval }
 	in inh_conv_coerce_to_tycon loc env evdref cj tycon
 
+    | GRun (loc, c) -> (*BETA*)
+        Run.pretype_run pretype inh_conv_coerce_to_tycon tycon env evdref lvar loc c
+
   (* [pretype_type valcon env evdref lvar c] coerces [c] into a type *)
   and pretype_type valcon env evdref lvar = function
     | GHole loc ->
diff -rupN coq-8.4pl1//pretyping/pretyping.mllib coq-8.4pl1M//pretyping/pretyping.mllib
--- coq-8.4pl1//pretyping/pretyping.mllib	2011-11-21 18:03:54.000000000 +0100
+++ coq-8.4pl1M//pretyping/pretyping.mllib	2013-01-18 11:05:35.000000000 +0100
@@ -25,5 +25,6 @@ Unification
 Detyping
 Indrec
 Cases
+Run
 Pretyping
 
diff -rupN coq-8.4pl1//pretyping/run.ml coq-8.4pl1M//pretyping/run.ml
--- coq-8.4pl1//pretyping/run.ml	1970-01-01 01:00:00.000000000 +0100
+++ coq-8.4pl1M//pretyping/run.ml	2013-03-26 16:59:07.000000000 +0100
@@ -0,0 +1,575 @@
+open List
+open String
+
+open Term
+open Termops
+open Reductionops
+open Environ
+open Evarutil
+open Evd
+open Names
+open Closure
+open Util
+open Evarconv
+open Libnames
+
+
+let isConstr c t = isConstruct t && eq_constructor (destConstruct t) c
+
+let mk_constr name = constr_of_global (Nametab.global_of_path (path_of_string name))
+
+module MtacNames = struct
+  let mtacore_name = "Mtac.mtacore"
+  let mtac_module_name = mtacore_name ^ ".MtacImp"
+  let mkConstr = fun e-> mk_constr (mtac_module_name ^ "." ^ e)
+  let mkT_lazy = lazy (mkConstr "T")
+
+  let mkBase = lazy (destInd (mkConstr "tpatt"), 1)
+  let mkTele = lazy (destInd (mkConstr "tpatt"), 2)
+
+  let isBase =  fun c->isConstr (Lazy.force mkBase) c
+  let isTele =  fun c->isConstr (Lazy.force mkTele) c
+
+end
+
+module Exceptions = struct
+
+  let mkInternalException = fun e -> mkApp (
+    MtacNames.mkConstr "InternalException", [|MtacNames.mkConstr e|])
+
+  let mkNullPointer = lazy (mkInternalException  "NullPointer")
+
+  (* HACK: we put Prop as the type of the raise. We can put an evar, but
+     what's the point anyway? *)
+  let mkRaise e = mkApp(MtacNames.mkConstr "raise", [|mkProp; Lazy.force e|]) 
+
+  let error_stuck = "Cannot reduce term, perhaps an opaque definition?"
+  let error_param = "Parameter appears in returned value"
+  let error_no_match = "No pattern matches"
+  let error_abs = "Cannot abstract non variable"
+
+  let raise = error
+end
+
+let mkT () = Lazy.force MtacNames.mkT_lazy
+
+let mk_ind path s =
+  encode_mind (dirpath_of_string path) (id_of_string s)
+
+module CoqList = struct
+  let t    = (mk_ind "Coq.Init.Datatypes" "list", 0)
+  let nil  = (t, 1)
+  let cons = (t, 2)
+
+  let isNil  = isConstr nil
+  let isCons = isConstr cons
+end
+
+module CoqEq = struct
+  let t       = (mk_ind "Coq.Init.Logic" "eq", 0)
+  let eq_refl = mkConstruct (t, 1)
+
+  let mkEq a x y = mkApp(mkInd t, [|a;x;y|])
+  let mkEqRefl a x = mkApp(eq_refl, [|a;x|])
+end
+
+module CoqSigT = struct
+  let t    = (mk_ind "Coq.Init.Specif" "sigT", 0)
+  let existT  = (t, 1)
+
+  let mkExistT a p x px =
+    mkApp (mkConstruct existT, [|a; p; x; px|])
+end
+
+module CoqNat = struct
+  let t    = (mk_ind "Coq.Init.Datatypes" "nat", 0)
+  let zero = (t, 1)
+  let succ = (t, 2)
+
+  let isZero = isConstr zero
+  let isSucc = isConstr succ
+
+  let rec to_coq = function
+    | 0 -> mkConstruct zero
+    | n -> Term.mkApp (mkConstruct succ, [| to_coq (pred n) |])
+
+  let rec from_coq' reentrant env evd c =
+    if isZero c then
+      0
+    else 
+      let (s, n) = destApp c in
+      begin
+      if isSucc s then
+        1 + (from_coq' false env evd (n.(0)))
+      else if reentrant then
+	anomaly "Not a nat"
+      else
+	let c' = Tacred.cbv_betadeltaiota env evd c in
+	from_coq' true env evd c'
+      end
+
+  let from_coq = from_coq' false
+
+end
+
+(** References are encoded with a new type, different from nat,
+so it's easier to check when a proof term has a reference *)
+module MyNat = struct
+  let ref_t= lazy (mk_constr (MtacNames.mtacore_name ^ ".MyNatRef.t'"))
+  let mkRef= lazy (destInd (Lazy.force ref_t), 1)
+  let isRef =  fun c->isConstr (Lazy.force mkRef) c
+
+  let t    = lazy (mk_constr (MtacNames.mtacore_name ^ ".MyNatRef.MyNat"))
+  let zero = lazy (destInd (Lazy.force t), 1)
+  let succ = lazy (destInd (Lazy.force t), 2)
+
+  let isZero =  fun c->isConstr (Lazy.force zero) c
+  let isSucc =  fun c->isConstr (Lazy.force succ) c
+
+  let rec to_coq = function
+    | 0 -> mkConstruct (Lazy.force zero)
+    | n -> Term.mkApp (mkConstruct (Lazy.force succ), [| to_coq (pred n) |])
+
+  let ref_to_coq a n = 
+    Term.mkApp (mkConstruct (Lazy.force mkRef), [|a ; to_coq n|])
+
+  let rec from_coq c =
+    if isZero c then
+      0
+    else 
+      let (s, n) = destApp c in
+      begin
+      if isSucc s then
+        1 + (from_coq (n.(0)))
+      else
+	anomaly "Not a MyNat number"
+      end
+
+  let rec ref_from_coq' reentrant env evd c =
+    let (h, a) = destApp c in
+    if isRef h then
+      from_coq a.(1)
+    else if reentrant then
+      anomaly "Not a reference"
+    else
+      try
+	let c' = Tacred.cbv_betadeltaiota env evd c in
+	ref_from_coq' true env evd c'
+      with _ -> 
+	anomaly "Not a reference"
+
+  let ref_from_coq = ref_from_coq' false
+end
+
+(** An array that grows 1.5 times when it gets out of space *) 
+module GrowingArray = struct
+  type 'a t = 'a array ref * 'a * int ref
+  
+  let make i t = (ref (Array.make i t), t, ref 0)
+  let length g = let (_, _, i) = g in !i
+  let get g = let (a, _, _) = g in Array.get !a
+  let set g = let (a, _, _) = g in Array.set !a
+
+  let add g t =
+    let (a, e, i) = g in
+    begin
+    if Array.length !a <= !i then
+      a := Array.append !a (Array.make (Array.length !a / 2) e)
+    else
+      ()
+    end;
+    Array.set !a !i t;
+    i := !i+1
+ 
+end
+
+module Refs = struct
+  let bag = ref (GrowingArray.make 4 None)
+
+  let clean () = 
+    bag := GrowingArray.make 4 None
+
+  let length () =
+    GrowingArray.length !bag
+
+  let check_context undo index c =
+    let size = List.length undo in
+    let rec check depth t =
+      match kind_of_term t with
+      | Rel k ->
+        if depth < k && k <= depth + size then
+          let rl = List.nth undo (k - depth -1) in
+          rl := (index :: !rl)
+        else
+          ()
+      | _ -> iter_constr_with_binders succ check depth t
+    in
+    check 0 c
+
+  let new_ref undo a c =
+    let level = List.length undo in
+    GrowingArray.add !bag (Some (c, level));
+    let index = pred (GrowingArray.length !bag) in
+    check_context undo index c;
+    MyNat.ref_to_coq a index
+
+  exception NullPointerException
+
+  let get env evd undo i = 
+    let level = List.length undo in
+    let index = MyNat.ref_from_coq env evd i in
+    let v = GrowingArray.get !bag index in
+    match v with
+      None -> raise NullPointerException
+    | Some (c, l) -> (lift (level - l) c)
+
+  (* HACK SLOW *)
+  let remove_all undo index =
+    List.iter (fun rl ->
+      rl := List.filter (fun i -> i <> index) !rl) undo
+
+  let set env evd undo i c = 
+    let level = List.length undo in
+    let index = MyNat.ref_from_coq env evd i in
+    remove_all undo index;
+    check_context undo index c;
+    GrowingArray.set !bag index (Some (c, level))
+
+  let invalidate index =
+    GrowingArray.set !bag index None
+    
+end
+
+
+type data = Val of (evar_map * constr) | Err of constr
+
+let (>>=) v g =
+  match v with
+    | Val v' -> g v'
+    | _ -> v
+
+let return s t = Val (s, t)
+
+let fail t = Err t
+(*
+let uflags =
+  { Unification.default_unify_flags with
+    Unification.modulo_eta = false }
+*)
+let rec open_pattern (env, sigma) p evars =
+  let (patt, args) = whd_betadeltaiota_stack env sigma p in
+  let length = List.length args in
+  let nth = List.nth args in
+  if MtacNames.isBase patt && length = 4 then
+    let p = nth 2 in
+    let b = nth 3 in
+    Some (sigma, evars, p, b)
+  else if MtacNames.isTele patt && length = 4 then
+    let c = nth 2 in
+    let f = nth 3 in
+    let (sigma', evar) = Evarutil.new_evar sigma env c in
+(*    let evar = Evarutil.new_meta () in
+    let sigma' = Evd.meta_declare evar c sigma in *)
+    open_pattern (env, sigma') (mkApp (f, [|evar|])) (evar :: evars)
+  else
+    None
+
+
+
+let rec runmatch' ?(reentrant = false) i (env, sigma as ctxt) t patts =
+  let (patts, args) = decompose_app patts in
+  if CoqList.isNil patts && List.length args = 1 then
+    Exceptions.raise Exceptions.error_no_match
+  else if CoqList.isCons patts && List.length args = 3 then
+      match open_pattern ctxt (List.nth args 1) [] with
+        Some (sigma', evars, p, body) ->
+          let rsigma' = ref sigma' in
+          begin
+            if unify env rsigma' p t && all_defined rsigma' (destEvars evars) then
+              let body = nf_evar !rsigma' body in
+              let () = remove_all rsigma' (destEvars evars) in
+              (!rsigma', body)
+            else
+              runmatch' (i+1) ctxt t (List.nth args 2)
+          end
+        | None -> Exceptions.raise Exceptions.error_stuck
+  else if not reentrant then
+    let patts = whd_betadeltaiota env sigma patts in
+    runmatch' ~reentrant:true i ctxt t patts
+  else
+    Exceptions.raise Exceptions.error_stuck
+
+and destEvars =
+  (* fun l -> l *)
+  List.map (fun e-> let ev, _ = destEvar e in ev)
+
+and all_defined rsigma =
+  (* List.fold_left (fun b e -> b && Evd.meta_defined !rsigma e) true *)
+  List.fold_left (fun b e -> b && Evd.is_defined !rsigma e) true
+
+and remove_all rsigma =
+  (* fun l -> () *)
+  List.iter (fun e -> rsigma := Evd.remove !rsigma e)
+
+and unify env rsigma t1 t2 =
+  try
+    let sigma = the_conv_x ~eta:false env t1 t2 !rsigma in
+    rsigma := consider_remaining_unif_problems env sigma; 
+    true
+    (*
+    rsigma := Unification.w_unify env !rsigma Reduction.CONV ~flags:uflags t1 t2;
+    true
+    *)
+  with _ -> false
+
+let runmatch = runmatch' 0
+
+
+
+let ind_ascii = (mk_ind "Coq.Strings.Ascii" "ascii", 0)
+
+let ind_string = (mk_ind "Coq.Strings.String" "string", 0)
+
+let ind_unit = (mk_ind "Coq.Init.Datatypes" "unit", 0)
+let unit_elem = (mkConstruct (ind_unit, 1))
+
+let mkBool = (mk_ind "Coq.Init.Datatypes" "bool", 0)
+let mkTrue = (mkBool, 1)
+let mkFalse = (mkBool, 2)
+
+let isTrue b = destConstruct b = mkTrue
+
+let to_ascii env sigma c =
+  let (h, args) = whd_betadeltaiota_stack env sigma c in
+  let rec bla n bits =
+    match bits with
+      | [] -> 0
+      | (b :: bs) -> (if isTrue b then 1 else 0) lsl n + bla (n+1) bs
+  in 
+  let n = bla 0 args in
+  Char.escaped (Char.chr n)
+
+let rec to_string env sigma s =
+  let (h, args) = whd_betadeltaiota_stack env sigma s in
+  if List.length args = 0 then (* assume is nil *)
+    ""
+  else (* assume is cons *)
+    let c, s' = List.nth args 0, List.nth args 1 in
+    to_ascii env sigma c ^ to_string env sigma s'
+    
+    
+let print env sigma s = Printf.printf "[DEBUG] %s\n" (to_string env sigma s)
+
+let mysubstn t n c =
+  let rec substrec depth c = match kind_of_term c with
+    | Rel k     ->
+        if k<=depth then c
+        else if k = depth+n then lift depth t
+        else mkRel (k+1)
+    | _ -> map_constr_with_binders succ substrec depth c in
+  substrec 0 c
+
+let rec run' ?(reentrant = false) (env, sigma, undo as ctxt) t =
+  let (h, args) = decompose_app t in
+  let nth = List.nth args in
+  let assert_args n = 
+    if List.length args = n then
+      ()
+    else
+      anomaly "The number of arguments for the constructor is wrong"
+  in
+  let constr c = 
+    if isConstruct h then
+      let (m, ix) = destConstruct h in
+      if eq_ind m (destInd (mkT ())) then
+	(true, ix)
+      else
+	(false, 0)
+    else
+      (false, 0)
+  in
+  match constr h with
+    (false, _) ->
+      if reentrant then
+        Exceptions.raise Exceptions.error_stuck
+      else
+	let t' = whd_betadeltaiota env sigma t in
+	run' ~reentrant:true ctxt t'
+    | (_, ix) ->
+    begin
+      match ix with
+      | 1 -> assert_args 2; (* ret *)
+	return sigma (Tacred.simpl env sigma (nth 1))
+      | 2 -> assert_args 4; (* bind *)
+	run' ctxt (nth 2) >>= fun (sigma', v) ->
+	let t' = whd_betadeltaiota env sigma (mkApp(nth 3, [|v|])) in
+	run' ~reentrant:true (env, sigma', undo) t'
+      | 3 -> assert_args 3; (* try *)
+	begin
+	match run' ctxt (nth 1) with
+	  | Val (sigma', v) -> return sigma' v
+	  | Err i -> 
+            let t' = whd_betadeltaiota env sigma (mkApp(nth 2, [|i|])) in
+            run' ~reentrant:true ctxt t'
+	end
+      | 4 -> assert_args 2; (* raise *)
+	fail (List.nth args 1)
+      | 5 -> assert_args 6; (* fix1 *)
+	let a, b, s, i, f, x = nth 0, nth 1, nth 2, nth 3, nth 4, nth 5 in
+	run_fix ctxt h [|a|] b s i f [|x|]
+      | 6 -> assert_args 8; (* fix 2 *)
+	let a1, a2, b, s, i, f, x1, x2 = nth 0, nth 1, nth 2, nth 3, nth 4, nth 5, nth 6, nth 7 in
+	run_fix ctxt h [|a1; a2|] b s i f [|x1; x2|]
+      | 7 -> assert_args 4; (* match *)
+	let (sigma', body) = runmatch (env, sigma) (nth 2) (nth 3) in
+	run' (env, sigma', undo) body
+      | 8 -> assert_args 1; (* print *)
+	let s = nth 0 in
+	print env sigma s;
+	return sigma unit_elem
+      | 9 -> assert_args 3; (* nu *)
+	let a, f = nth 0, nth 2 in
+	let fx = mkApp(lift 1 f, [|mkRel 1|]) in
+        let ur = ref [] in
+        begin
+	match run' (push_rel (Anonymous, None, a) env, sigma, (ur :: undo)) fx with
+          | Val (sigma', e) ->
+            clean !ur;
+	    if Intset.mem 1 (free_rels e) then
+              Exceptions.raise Exceptions.error_param
+	    else
+	      return sigma' (pop e)
+          | Err e -> 
+            clean !ur;
+	    if Intset.mem 1 (free_rels e) then
+              Exceptions.raise Exceptions.error_param
+	    else
+	      fail (pop e)
+        end
+      | 10 -> assert_args 2; (* is_param *)
+	let e = whd_betadeltaiota env sigma (nth 1) in
+	if isRel e then
+	  return sigma (mkConstruct mkTrue)
+	else
+	  return sigma (mkConstruct mkFalse)
+      | 11 -> assert_args 4; (* abs *)
+        let a, p, x, y = nth 0, nth 1, nth 2, nth 3 in
+        abs env sigma a p x y false
+      | 12 -> assert_args 4; (* abs_eq *)
+        let a, p, x, y = nth 0, nth 1, nth 2, nth 3 in
+        abs env sigma a p x y true
+      | 13 -> assert_args 1; (* evar *)
+	let t = nth 0 in
+	let (sigma', ev) = Evarutil.new_evar sigma env t in
+	return sigma' ev
+      | 14 -> assert_args 2; (* is_evar *)
+	let e = whd_betadeltaiota env sigma (nth 1) in
+	if isEvar e then
+	  return sigma (mkConstruct mkTrue)
+	else
+	  return sigma (mkConstruct mkFalse)
+      | 15 -> assert_args 2; (* ref *)
+	return sigma (Refs.new_ref undo (nth 0) (nth 1))
+      | 16 -> assert_args 2; (* read *)
+	begin
+	try
+	  return sigma (Refs.get env sigma undo (nth 1))
+	with Refs.NullPointerException ->
+	  fail (Lazy.force Exceptions.mkNullPointer)
+	end
+      | 17 -> assert_args 3; (* write *)
+	Refs.set env sigma undo (nth 1) (nth 2);
+	return sigma unit_elem
+      | 18 -> assert_args 3; (* hash *)
+        return sigma (hash ctxt (nth 1) (nth 2))
+      | _ ->
+	anomaly "I have no idea what is this construct of T that you have here"
+    end
+
+and abs env sigma a p x y eq_proof =
+  let x = whd_betadeltaiota env sigma x in
+  if isRel x then
+    let y' = mysubstn (mkRel 1) (destRel x) y in
+    let t = mkLambda (Anonymous, a, y') in
+    if eq_proof then
+      let ex_a = mkProd (Anonymous, a, mkApp(lift 1 p, [|mkRel 1|])) in
+      let px_type = mkApp(p, [|x|]) in
+      let ex_p = mkLambda (Anonymous, ex_a, CoqEq.mkEq px_type (mkApp(mkRel 1, [|lift 1 x|])) (lift 1 y)) in
+      let ex_x = t in
+      let ex_px = CoqEq.mkEqRefl px_type y in
+      return sigma (CoqSigT.mkExistT ex_a ex_p ex_x ex_px)
+    else
+      return sigma t
+  else
+    Exceptions.raise Exceptions.error_abs
+
+and clean =
+  List.iter (fun i -> Refs.invalidate i)
+  
+and run_fix (env, sigma, _ as ctxt) h a b s i f x =
+  let fixf = mkApp(h, Array.append a [|b;s;i;f|]) in
+  let c = mkApp (f, Array.append [| fixf|] x) in
+  let t' = whd_betadeltaiota env sigma c in
+  run' ~reentrant:true ctxt t'
+
+and hash (env, sigma, undo) c size =
+  let size = CoqNat.from_coq env sigma size in
+  let nus = List.length undo in
+  let rec upd depth t =
+    match kind_of_term t with
+    | Rel k ->
+      if depth < k then
+        begin
+        if k > depth + nus then
+          mkRel (k - nus)
+        else
+          mkRel (k + nus - (2 * (k -1)))
+        end
+      else
+        t
+    | _ -> map_constr_with_binders succ upd depth t
+  in
+  let h = Term.hash_constr (upd 0 c) in
+  CoqNat.to_coq (Pervasives.abs (h mod size))
+
+let assert_free_of_refs c =
+  if Refs.length () = 0 then
+    ()
+  else if occur_term (mkConstruct (Lazy.force MyNat.zero)) c then
+    anomaly "Returning a reference. This is not allowed since you might be naughty and use it in the next execution."
+  else ()
+
+let run (env, sigma) t  = 
+  let _ = Refs.clean () in
+  match run' (env, sigma, []) (nf_evar sigma t) with
+    | Err i -> 
+      assert_free_of_refs i;
+      Err i
+    | Val (sigma', v) -> 
+      assert_free_of_refs v;
+      Val (sigma', nf_evar sigma' v)
+
+
+let pretypeT pretype tycon env evdref lvar c =
+    let t = 
+      match tycon with
+      | Some (_, ty) -> ty
+      | _ ->
+        let sigma, univ = new_univ_variable !evdref in
+        evdref := sigma;
+        e_new_evar evdref env (mkType univ)
+    in
+    let tt = mkApp(mkT (), [|t|]) in
+    t, pretype (mk_tycon tt) env evdref lvar c
+
+let pretype_run pretype coerce_to_tycon tycon env evdref lvar loc c =
+   let t, r = pretypeT pretype tycon env evdref lvar c in
+   let d = run (env, !evdref) r.uj_val in
+   match d with
+       | Val (evmap, e) ->
+         evdref := evmap ;
+         let r = { uj_val = e; uj_type = t } in
+         coerce_to_tycon loc env evdref r tycon
+       | Err e -> 
+         Pretype_errors.error_user_exception loc env !evdref e
+
diff -rupN coq-8.4pl1//pretyping/run.mli coq-8.4pl1M//pretyping/run.mli
--- coq-8.4pl1//pretyping/run.mli	1970-01-01 01:00:00.000000000 +0100
+++ coq-8.4pl1M//pretyping/run.mli	2013-03-26 16:59:07.000000000 +0100
@@ -0,0 +1,21 @@
+open Term
+open Evd
+open Environ
+
+type data = Val of (evar_map * constr) | Err of constr
+
+val mkT : unit -> Term.constr
+
+val run : (env * evar_map) -> constr -> data
+
+val pretype_run : 
+  (Evarutil.type_constraint -> Environ.env -> Evd.evar_map ref -> 'a -> 'b -> Environ.unsafe_judgment) ->
+  (Util.loc -> Environ.env -> Evd.evar_map ref -> Environ.unsafe_judgment -> ('c * Term.types) option -> 'd) ->
+  ('c * Term.types) option ->
+  Environ.env -> Evd.evar_map ref -> 'a -> Util.loc -> 'b -> 'd
+
+
+(* debug *)
+val to_string : env -> evar_map -> constr -> string
+val to_ascii : env -> evar_map -> constr -> string
+val run' : ?reentrant:bool -> (env * evar_map * int list ref list) -> constr -> data
diff -rupN coq-8.4pl1//theories/theories.itarget coq-8.4pl1M//theories/theories.itarget
--- coq-8.4pl1//theories/theories.itarget	2010-12-10 14:22:29.000000000 +0100
+++ coq-8.4pl1M//theories/theories.itarget	2013-03-04 09:16:35.000000000 +0100
@@ -22,3 +22,4 @@ Strings/vo.otarget
 Unicode/vo.otarget
 Wellfounded/vo.otarget
 ZArith/vo.otarget
+Mtac/vo.otarget
diff -rupN coq-8.4pl1//toplevel/himsg.ml coq-8.4pl1M//toplevel/himsg.ml
--- coq-8.4pl1//toplevel/himsg.ml	2012-08-08 20:54:37.000000000 +0200
+++ coq-8.4pl1M//toplevel/himsg.ml	2013-03-25 09:15:04.000000000 +0100
@@ -503,6 +503,12 @@ let explain_type_error env sigma err =
   | WrongCaseInfo (ind,ci) ->
       explain_wrong_case_info env ind ci
 
+(* BETA *)
+let explain_user_exception env sigma c =
+  let c = nf_evar sigma c in
+  let pr = pr_lconstr_env env c in
+  str "Uncaught user exception:" ++ spc () ++ pr
+
 let explain_pretype_error env sigma err =
   let env = env_nf_betaiotaevar sigma env in
   let env = make_all_name_different env in
@@ -524,6 +530,8 @@ let explain_pretype_error env sigma err
   | AbstractionOverMeta (m,n) -> explain_abstraction_over_meta env m n
   | NonLinearUnification (m,c) -> explain_non_linear_unification env m c
   | TypingError t -> explain_type_error env sigma t
+(* BETA *)
+  | UncaughtUserException c -> explain_user_exception env sigma c
 
 (* Module errors *)
 
diff -rupN coq-8.4pl1//user-contrib/Mtac/hash.v coq-8.4pl1M//user-contrib/Mtac/hash.v
--- coq-8.4pl1//user-contrib/Mtac/hash.v	1970-01-01 01:00:00.000000000 +0100
+++ coq-8.4pl1M//user-contrib/Mtac/hash.v	2013-03-22 18:08:16.000000000 +0100
@@ -0,0 +1,160 @@
+Require Import mtac.
+Require Import Arith Lists.List.
+Import ListNotations.
+
+
+Module ListMtactics.
+
+  Definition NotFound : Exception.
+    exact exception.
+  Qed.
+
+  Definition inlist {A} (x : A) :=
+    mfix f [s : list A] : T (In x s)  :=
+      mmatch s with
+      | [l r] l ++ r => 
+        mtry 
+          il <- f l;
+          ret (in_or_app l r x (or_introl il))
+        with NotFound  =>
+          ir <- f r;
+          ret (in_or_app l r x (or_intror ir))
+        end
+      | [s'] (x :: s') => ret (in_eq _ _)
+      | [y s'] (y :: s') =>
+        r <- f s';
+        ret (in_cons y _ _ r)
+      | _ => raise NotFound
+      end.
+    
+  Program
+  Definition find {A} {B : A -> Type} (x : A) :=
+    mfix f [s : list (sigT B)] : T (B x) :=
+      mmatch s with
+      | [l r] l ++ r => 
+        mtry 
+          f l
+        with NotFound =>
+          f r
+        end
+      | [y s'] (existT B x y :: s') => ret y
+      | [y s'] (y :: s') => f s'
+      | _ => raise NotFound
+      end.
+
+End ListMtactics.
+
+Module HashTbl.
+  
+
+  Definition t A (P : A -> Type) := (MyNatRef.t nat * MyNatRef.t (Array.t (list (sigT P))))%type.
+
+  Definition initial_size := 16.
+  Definition inc_factor := 2.
+  Definition threshold := 7.
+
+  Definition NotFound : Exception.
+    exact exception.
+  Qed.
+
+  Definition create A B : T (t A B) :=
+    n <- ref 0;
+    a <- Array.make initial_size nil;
+    ra <- ref a;
+    ret (n, ra).
+
+  
+  Definition quick_add {A P} (a : Array.t (list (sigT P))) (x : A) (y : P x) : T unit :=
+    i <- hash x (Array.length a);
+    l <- Array.get a i;
+    Array.set a i (existT _ x y  :: l).
+
+  
+  Definition iter {A B} (h : t A B) (f : forall x : A, B x -> T unit) : T unit :=
+    let (_, ra) := h in
+    a <- !ra;
+    let size := Array.length a in
+    let execute i :=
+       l <- Array.get a i;
+       fold_right (fun k r => r;;
+         match k with
+           existT x y => f x y
+         end) (ret tt) l
+    in
+    let loop := fix lp n := 
+      match n with
+      | 0 => ret tt
+      | S n' => execute n';; lp n'
+      end
+    in
+    loop size.
+
+  Definition expand {A B} (h : t A B) : T unit :=
+    let (load, ra) := h in
+    a <- !ra;
+    let new_size := Array.length a * inc_factor in
+    new_a <- Array.make new_size nil;
+    iter h (fun x y=> quick_add new_a x y);;
+    ra ::= new_a.
+        
+
+  (* There is no order on the elements *)
+  Definition to_list {A B} (h : t A B) :=
+    rl <- ref nil;
+    HashTbl.iter h (fun x y => l <- !rl; rl ::= (existT _ x y :: l));;
+    !rl.
+
+  (* debugging function to test how big is the biggest bucket *)
+  Definition max_bucket {A B} (h : t A B) :=
+    let (_, ra) := h in
+    a <- !ra;
+    let size := Array.length a in
+    let execute i :=
+       l <- Array.get a i;
+       ret (length l)
+    in
+    max <- ref 0;
+    let loop := fix lp n := 
+      match n with
+      | 0 => !max
+      | S n' => 
+        size <- execute n';
+        prev <- !max;
+        if leb prev size then
+          max ::= size;; lp n'
+        else
+          lp n'
+      end
+    in
+    loop size;;
+    !max.
+    
+
+  Definition add {A B} (h : t A B) (x : A) (y : B x) :=
+    let (rl, ra) := h in
+    load <- !rl;
+    a <- !ra;
+    let size := Array.length a in
+    (if (leb (threshold * size) (10 * load)) then
+      print "expanding";;
+      expand h
+    else
+      ret tt);;
+    a <- !ra;
+    quick_add a x y;;
+    rl ::= (S load).
+
+  Definition find {A B} (h : t A B) (x : A) : T (B x) :=
+    x' <- ret x;
+    let (_, ra) := h in
+    a <- !ra;
+    i <- hash x' (Array.length a);
+    l <- Array.get a i;
+    mtry
+      ListMtactics.find x l
+    with ListMtactics.NotFound =>
+      raise NotFound
+    end.
+
+  
+End HashTbl.
diff -rupN coq-8.4pl1//user-contrib/Mtac/mtac.v coq-8.4pl1M//user-contrib/Mtac/mtac.v
--- coq-8.4pl1//user-contrib/Mtac/mtac.v	1970-01-01 01:00:00.000000000 +0100
+++ coq-8.4pl1M//user-contrib/Mtac/mtac.v	2013-02-27 01:43:58.000000000 +0100
@@ -0,0 +1,37 @@
+Require Export mtacore.
+
+Export MtacNotations.
+
+Obligation Tactic := idtac.
+
+
+Class runner A  (f : T A) := { eval : A }.
+Implicit Arguments runner [A].
+Implicit Arguments Build_runner [A].
+Implicit Arguments eval [A runner].
+
+Hint Extern 20 (runner ?f) => (exact (Build_runner f (run f)))  : typeclass_instances.
+
+Coercion eval : T >-> Funclass.
+
+
+(*
+Definition test :=
+  try x <- 
+    try ret 0 
+    with e => ret 1 ; 
+    ret x 
+  with e => ret 2.
+
+Set Printing Existential Instances.
+
+Definition inlist (x : nat) := 
+  ufix f [ s : list nat ] =>
+  umatch s as s' return T (In x s') with
+  | [ s' ] x::s' => ret (in_eq x s') 
+  | [y s] y :: s => 
+    t <- f s ;
+    ret (in_cons y x s t)
+  | _ => raise 0
+  end.
+*)
\ No newline at end of file
diff -rupN coq-8.4pl1//user-contrib/Mtac/mtacore.v coq-8.4pl1M//user-contrib/Mtac/mtacore.v
--- coq-8.4pl1//user-contrib/Mtac/mtacore.v	1970-01-01 01:00:00.000000000 +0100
+++ coq-8.4pl1M//user-contrib/Mtac/mtacore.v	2013-03-27 19:04:08.000000000 +0100
@@ -0,0 +1,277 @@
+Require Import Strings.String.
+Require Import Lists.List.
+
+
+Module Type Ref.
+  Parameter t : Type -> Type.
+End Ref.
+
+Module MyNatRef <: Ref.
+  Inductive MyNat := 
+    zero : MyNat 
+  | succ : MyNat -> MyNat.
+    
+  Inductive t' (a : Type) := 
+    | mkRef : MyNat -> t' a.
+
+  Definition to_nat {A} (r : t' A) :=
+    match r with
+    | mkRef n => n
+    end.
+
+  Definition build {A} (r : t' A) n :=
+    let i := to_nat r in
+    let add := 
+      fix f m := match m with
+                 | 0 => i
+                 | S n' => succ (f n')
+                 end
+    in mkRef A (add n).
+
+  Definition t := fun a=>t' a.
+End MyNatRef.
+
+
+Module Mtac (rf : Ref).
+
+Inductive Exception : Type := exception : Exception.
+
+Definition InternalException : Exception -> Exception.
+  exact id.
+Qed.
+
+Definition NullPointer : Exception.
+  exact exception.
+Qed.
+
+
+Inductive T : Type -> Prop :=
+| ret : forall {A}, A -> T A
+| bind : forall {A B}, T A -> (A -> T B) -> T B
+| ttry : forall {A}, T A -> (Exception -> T A) -> T A
+| raise : forall {A}, Exception -> T A
+| tfix1' : forall {A B} (S : Type -> Prop), 
+  (forall a, S a -> T a) ->
+  ((forall x : A, S (B x)) -> (forall x : A, S (B x))) -> 
+  forall x : A, T (B x)
+| tfix2' : forall {A1 A2 B} (S : Type -> Prop), 
+  (forall a, S a -> T a) ->
+  ((forall (x1 : A1) (x2 : A2 x1), S (B x1 x2)) -> 
+    (forall (x1 : A1) (x2 : A2 x1), S (B x1 x2))) -> 
+  forall (x1 : A1) (x2 : A2 x1), T (B x1 x2)
+| tmatch : forall {A} B (t : A), list (tpatt A B) -> T (B t)
+| print : string -> T unit
+| tnu : forall {A B}, (A -> T B) -> T B
+| is_var : forall {A}, A -> T bool
+| abs : forall {A P} (x : A), P x -> T (forall x, P x)
+| abs_eq : forall {A} {P} (x : A) (y : P x), 
+  T (sigT (fun f : (forall x':A, P x')=> f x = y))
+| evar : forall A, T A
+| is_evar : forall {A}, A -> T bool
+
+| ref : forall {A}, A -> T (rf.t A)
+| read : forall {A}, rf.t A -> T A
+| write : forall {A}, rf.t A -> A -> T unit
+
+| hash : forall {A}, A -> nat -> T nat
+
+with tpatt : forall A (B : A -> Type), Type := 
+| base : forall {A B} (x:A) (b : T (B x)), tpatt A B
+| tele : forall {A B C}, (forall (x : C), tpatt A B) -> tpatt A B.
+
+Definition tfix1 {A} B := @tfix1' A B T (fun _ x => x).
+Definition tfix2 {A1 A2} B := @tfix2' A1 A2 B T (fun _ x => x).
+
+End Mtac.
+
+Module MtacImp := Mtac MyNatRef.
+
+Export MtacImp.
+    
+
+
+Module MtacNotations.
+
+Notation "r '<-' t1 ';' t2" := (@bind _ _ t1 (fun r=>t2)) 
+  (at level 81, right associativity). 
+Notation "t1 ';;' t2" := (@bind _ _ t1 (fun _=>t2)) 
+  (at level 81, right associativity).
+Notation "f @@ x" := (bind f (fun r=>ret (r x))) (at level 90).
+Notation "f >> x" := (bind f (fun r=>x r)) (at level 90).
+
+Notation "'mfix' f [ x ] := b" := (tfix1 (fun _=>_) (fun f x=>b)) 
+  (at level 85, f at level 0, x at level 0).
+Notation "'mfix' f [ x : t ] := b" := (tfix1 (fun _ : t =>_) (fun f x=>b))
+  (at level 85, f at level 0, x at level 0).
+Notation "'mfix' f [ x ] : 'T' A := b" := (tfix1 (fun x=>A) (fun f x=>b)) 
+  (at level 85, f at level 0, x at level 0).
+Notation "'mfix' f [ x : t ] : 'T' A := b" := (tfix1 (fun x:t=>A) (fun f x=>b)) 
+  (at level 85, f at level 0, x at level 0).
+
+Notation "'mfix' f [ x1 ; x2 ] := b" := (tfix2 (fun _ _ =>_) (fun f x1 x2=>b)) 
+  (at level 85, f at level 0, x1 at level 0, x2 at level 0).
+Notation "'mfix' f [ x1 : t1 ; x2 : t2 ] := b" :=
+  (tfix2 (fun _ _=>_) (fun f (x1 : t1) (x2 : t2)=>b)) 
+  (at level 85, f at level 0, x1 at level 0, x2 at level 0).
+Notation "'mfix' f [ x1 ; x2 ] : 'T' A := b" := 
+  (tfix2 (fun x1 x2=>A) (fun f x1 x2=>b))
+  (at level 85, f at level 0, x1 at level 0, x2 at level 0).
+Notation "'mfix' f [ x1 : t1 ; x2 : t2 ] : 'T' A := b" := 
+  (tfix2 (fun (x1:t1) (x2:t2)=>A) (fun f (x1:t1) (x2:t2)=>b))
+  (at level 85, f at level 0, x1 at level 0, x2 at level 0).
+
+Notation "[ x .. y ] ps" := (tele (fun x=> .. (tele (fun y=>ps)).. ))
+  (at level 202, x binder, y binder, ps at next level) : mtac_patt_scope.
+Notation "p => b" := (base p%core b%core) 
+  (no associativity, at level 201) : mtac_patt_scope. 
+Notation "'_' => b " := (tele (fun x=> base x b%core)) 
+  (at level 201, b at next level) : mtac_patt_scope.
+
+Delimit Scope mtac_patt_scope with mtac_patt.
+
+Notation "'mmatch' t 'with' | p1 | .. | pn 'end'" := 
+  (tmatch (fun _=>_) t (cons p1%mtac_patt (.. (cons pn%mtac_patt nil) ..))) 
+    (at level 90, p1 at level 210, pn at level 210).
+Notation "'mmatch' t 'return' 'T' p 'with' | p1 | .. | pn 'end'" := 
+  (tmatch (fun _=>p) t (cons p1%mtac_patt (.. (cons pn%mtac_patt nil) ..))) 
+    (at level 90, p1 at level 210, pn at level 210).
+Notation "'mmatch' t 'as' x 'return' 'T' p 'with' | p1 | .. | pn 'end'" := 
+  (tmatch (fun x=>p) t (cons p1%mtac_patt (.. (cons pn%mtac_patt nil) ..))) 
+    (at level 90, p1 at level 210, pn at level 210).
+
+Notation "'mmatch' t 'with' p1 | .. | pn 'end'" := 
+  (tmatch (fun _=>_) t (cons p1%mtac_patt (.. (cons pn%mtac_patt nil) ..))) 
+    (at level 90, p1 at level 210, pn at level 210).
+Notation "'mmatch' t 'return' 'T' p 'with' p1 | .. | pn 'end'" := 
+  (tmatch (fun _=>p) t (cons p1%mtac_patt (.. (cons pn%mtac_patt nil) ..))) 
+    (at level 90, p1 at level 210, pn at level 210).
+Notation "'mmatch' t 'as' x 'return' 'T' p 'with' p1 | .. | pn 'end'" := 
+  (tmatch (fun x=>p) t (cons p1%mtac_patt (.. (cons pn%mtac_patt nil) ..))) 
+    (at level 90, p1 at level 210, pn at level 210).
+
+
+Notation "'mtry' a 'with' | p1 | .. | pn 'end'" := 
+  (ttry a (fun e=>
+    (tmatch (fun _=>_) e (cons p1%mtac_patt (.. (cons pn%mtac_patt (cons (tele (fun x=> base x (raise x))) nil)) ..)))))
+    (at level 82, p1 at level 210, pn at level 210).
+
+Notation "'mtry' a 'with' p1 | .. | pn 'end'" := 
+  (ttry a (fun e=>
+    (tmatch (fun _=>_) e (cons p1%mtac_patt (.. (cons pn%mtac_patt (cons (tele (fun x=> base x (raise x))) nil)) ..)))))
+    (at level 82, p1 at level 210, pn at level 210).
+
+Notation "'nu' x .. y , a" := (tnu (fun x=>.. (tnu (fun y=> a))..)) 
+(at level 81, x binder, y binder, right associativity). 
+      
+
+Notation "! a" := (read a) (at level 80).
+Notation "a ::= b" := (write a b) (at level 80).
+
+(*
+Definition notation_test : T nat :=
+  mmatch 0 with 
+    0 => ret 0 
+  | 1 => ret 1
+  | [x y] x + y =>
+     mtry 
+      ret (match x with 
+               O => y
+             | S n => x end) 
+     with 0 => ret 0 | _ => ret 1 end
+  end.
+
+Require Import List.
+Import ListNotations.
+Open Scope list_scope.
+
+Definition notation_test2  :=
+  mmatch [1;2] with 
+    ([1]) => match [1] with [1] => ret [1] | _ => ret [0] end
+  | [x] ([x ; 2]) => ret [x]
+  | [x y] x ++ y  => ret [0;1]
+  | [x y] x :: y  => ret [0;1]
+  end.
+*)
+
+End MtacNotations.
+
+
+
+Module Array.
+  Require Import Arith_base.
+
+  Import MtacNotations.
+
+  Definition t A := (nat * MyNatRef.t A)%type.
+
+  Definition EmptyArrayException : Exception.
+    exact exception.
+  Qed.
+
+  Definition init {A} n (f : nat -> T A) :=
+    if leb n 0 then raise EmptyArrayException
+    else
+      a <- f 0;
+      first <- ref a;
+      let init := fix loop i n := 
+        match n with
+        | 0 => ret tt (* impossible case *)
+        | 1 => ret tt (* already created (first) *)
+        | S n' => 
+          b <- f i;
+          ref b;; loop (S i) n'
+        end in
+      init 1 n;;
+      ret (n, first).
+
+  Definition make {A} n (c : A)  := 
+    init n (fun _=>ret c).
+    
+
+  Definition length {A} (a : t A) :=
+    let (n, _) := a in n.
+
+  Definition OutOfBoundsException : Exception.
+    exact exception.
+  Qed.
+
+  Definition get {A} (a : t A) i :=
+    let (n, r) := a in
+    if leb (S i) n then
+      rf <- ret (MyNatRef.build r i); (* HACK: I know it's simplifying in return *)
+      !rf
+    else
+      raise OutOfBoundsException.
+
+  Definition set {A} (a : t A) i (c : A) :=
+    let (n, r) := a in
+    if leb (S i) n then
+      rf <- ret (MyNatRef.build r i); (* HACK: I know it's simplifying in return *)
+      rf ::= c
+    else
+      raise OutOfBoundsException.
+
+  Definition to_list {A} (a : t A) :=
+    let tl :=
+      fix f i :=
+        match i with
+        | 0 => ret nil
+        | S n => 
+          r <- f n;
+          e <- get a n;
+          ret (r ++ (e :: nil))
+        end
+    in tl (length a).
+
+  Definition copy {A} (a b : t A) :=
+    let cp :=
+      fix f i :=
+        match i with
+        | 0 => ret tt
+        | S n => 
+          e <- get a n;
+          set b n e
+        end
+    in cp (length b).
+    
+End Array.
diff -rupN coq-8.4pl1//user-contrib/Mtac/v.itarget coq-8.4pl1M//user-contrib/Mtac/v.itarget
--- coq-8.4pl1//user-contrib/Mtac/v.itarget	1970-01-01 01:00:00.000000000 +0100
+++ coq-8.4pl1M//user-contrib/Mtac/v.itarget	2013-03-15 06:50:29.000000000 +0100
@@ -0,0 +1,4 @@
+mtacore.v
+mtac.v
+hash.v
+
